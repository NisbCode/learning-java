Serve para ordenar listas

Uso da classe Produto, da SortProdutoTest e da classe SortList para o estudo desta aula
Métodos hashcoe e equals podem ser colocados para sobreescrever usando alt+insert
A Interface Comparable TEM q ser implementada ao seu produto o qual será ordenado para assim vc poder dizer como será organizado sua lista 


package Estudando.javacore.Y_colecoes.classes;

import java.util.Objects;

//Implementa a Interface Comparable para que vc possa dizer cm seu produto deve ser ordenado
//Vc tb terá   q sobreescrever seus métodos
public class Produto implements Comparable<Produto> {
    private String serialNumber;  //Dois produtos são iguais quando o número do serial deles tb forem
    private String nome;
    private double preco;
    private int quantidade;

    public Produto(String serialNumber, String nome, Double preco) { //Construtor para a classe SortProdutoTest q terá estes parâmetros para seus produtos
        this.serialNumber = serialNumber;
        this.nome = nome;
        this.preco = preco;
    }

    public Produto(String serialNumber, String nome, Double preco, int quantidade) {
        this.serialNumber = serialNumber;
        this.nome = nome;
        this.preco = preco;
        this.quantidade = quantidade;
    }

    // métodos equals e hashcode: "Se um produto tiver o HASHCODE do serial number
    // EQUALS ao de outro produto, eles serão considerados iguais"
    // Então aq tamos sobreescrevendo
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Produto produto = (Produto) o;
        return Objects.equals(serialNumber, produto.serialNumber);
    }

    @Override
    public int hashCode() {
        return Objects.hash(serialNumber);
    }


    @Override
    public String toString() {
        return "Produto{" +
                "serialNumber='" + serialNumber + '\'' +
                ", nome='" + nome + '\'' +
                ", preco=" + preco +
                ", quantidade=" + quantidade +
                '}';
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public Double getPreco() {
        return preco;
    }

    public void setPreco(Double preco) {
        this.preco = preco;
    }

    public String getSerialNumber() {
        return serialNumber;
    }

    public void setSerialNumber(String serialNumber) {
        this.serialNumber = serialNumber;
    }

    public int getQuantidade() {
        return quantidade;
    }

    public void setQuantidade(int quantidade) {
        this.quantidade = quantidade;
    }

    // Ao implementar a interface Comparable, deve-se também
    // implementar os métodos dela, ness caso, o compareTo
    @Override
    public int compareTo(Produto outroObjeto) {
        // Para pôr o serialNumber em ordem crescente
//        return this.serialNumber.compareTo(outroObjeto.getSerialNumber());
        // Para pôr os nomes em ordem crescente
//        return this.nome.compareTo(outroObjeto.getNome());
        // Para pôr os precos em ordem crescente (lembrando que
        // os tipos devem ser Wrappers, não primitivos)
        Double d = preco;
        return d.compareTo(outroObjeto.getPreco()); //Isso pq valores primitivos n tem método
    }
}





package Estudando.javacore.Y_colecoes.test;


import Estudando.javacore.Y_colecoes.classes.Produto;

import java.util.*;

/***
 * COMPARATOR:
 * Alternativa a interface Comparable
 * caso o padrão de ordem deva ser mudado depois que o
 * método compareTo já foi chamado
 */
class ProdutoNomeComparatorimplements Comparator<Produto> {

    @Override
    // Aqui são dois argumentos porque o outro compara
    // elementos da própria classe com outros, aqui
    // estamos pegandos dois elementos de outra classe pra
    // comparar e nenhum dessa
    public int compare(Produto o1, Produto o2) {
        return o1.getNome().compareTo(o2.getNome());
    }
}

public class SortProdutoTest {
    public static void main(String[] args) {
        List<Produto> produtos = new ArrayList<>();
        Produto produto1 = new Produto("123", "Laptop Lenovo", 2000.0);
        Produto produto2 = new Produto("321", "Picanha", 26.4);
        Produto produto3 = new Produto("878", "Teclado Razer", 1000.0);
        Produto produto4 = new Produto("012", "Samsung Galaxy S7", 3250.0 );

        produtos.add(produto1);  //Para adicionar estes produtos a lista de produtos
        produtos.add(produto2);
        produtos.add(produto3);
        produtos.add(produto4);

        // Nesse caso, não tem um padrão pré definido,
        // sendo assim, o java vai dar erro de compilação
        // Para contornar isso, deve-se implementar a classe
        // Comparable

        // Depois da lista vem o padrão do Comparator
        Collections.sort(produtos, new ProdutoNomeComparator());

        System.out.println("Produtos na List:");
        for (Produto produto : produtos){
            System.out.println(produto);
        }

        // Também funciona com Arrays:
        Produto[] produtoArray = new Produto[4];
        produtoArray[0] = produto1;
        produtoArray[1] = produto2;
        produtoArray[2] = produto3;
        produtoArray[3] = produto4;

        // Para imprimir um array é possível usar isso,
        // ao invés do for
        System.out.println(" ");
        System.out.println("Produtos impressos em Array");
        System.out.println(Arrays.toString(produtoArray));

        // Agora usando um método sort() num array
        System.out.println(" ");
        System.out.println("Produtos com sort() em Array:");
        // Vai ter o padrão definido pela Camparable, se não
        // for adicionado o Comparator
        Arrays.sort(produtoArray);
        for (Produto produto : produtoArray){
            System.out.println(produto);
        }

    }
}





package Estudando.javacore.Y_colecoes.test;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class SortListTest {
    public static void main(String[] args) {
        // Lista de nomes
        List<String> nomes = new ArrayList<>();
        nomes.add("Naty");
        nomes.add("Bomfim");
        nomes.add("Melanie");
        nomes.add("Martinez");
        // Para colocar um item antes do outro
        // na compilação, só colocar o índice antes
        nomes.add(0, "Billie");


        /**
         * MÉTODO SORT:
         */

        Collections.sort(nomes);  //Classe Collections; método sort; com parâmetro da lsita
//      Ele ordena como a String (Q é o caso dessa lista) deve ser ordenada

        for (String nome : nomes){
            System.out.println(nome);
        }

        // Lista de numeros
        List<Double> numeros = new ArrayList<>();
        numeros.add(1.1);
        numeros.add(1.5);
        numeros.add(1.3);
        numeros.add(1.9);
        numeros.add(2d);

        // Método sort
        Collections.sort(numeros);

        for (Double numero : numeros){
            System.out.println(numero);
        }

    }
}