Uso as Classes: WildCardTest, Animal, Cachorro e Gato

Caractere Coringa de Generics
Ele praticamente diz que recebe qualquer lista desde q seja filha da classe definida
Sua simbologia é expressa pelo "?"
Porém se vc usar aquele caractere coringa vc n vai poder adicionar uma Classe
N se esqueça de q tds as classes são filhas da classe object

Okay, isso serve basicamente de forma a contornar um problema no uso de List, já q Array pode ter o uso de Classes mães e filhas ao ser chamado
Por ex.:
    public static void consultarAnimaisList(List<Animal> animals) {   <---Criou uma lista de animais

        List<Cachorro> cachorroList = new ArrayList<>();                 <---Criou uma lista de Cachorros

        consultarAnimaisList(cachorroList);                                            <---Chamou a lista de cachorros dentro da lista de animais

Em Array, isto seria possível
Porém aq, cm vc disse q vc criou uma lista de ANIMAIS, ele tá esperando os animais, não subclasses
Para contornar usamos o método coringa

    public static void consultarAnimaisList(List<? extends Animal> animals) {

Q vai dizer q vc quer qualquer uma q seja filha da classe pedida


    public static void consultarCachorroList(List<? super Cachorro> cachorroList){

Ou qualquer uma acima dela, classes mães, da q vc pediu


Também é possível criar condições

    public static void ordenarLista(List<? extends Comparable> lista){




package Estudando.javacore.Z_generics.test;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/***
 * WILDCAST CORINGA
 * Possibilita que parâmetros de métodos permitam
 * que argumentos façam polimorfismo em listas
 * Deve ser adicionado quando a lista está toda pronta,
 * todos os itens adicionados, porque, após isso, dá erro
 * de compilação a adição de novos itens
 */

abstract class Animal {
    public abstract void consulta();
}

class Cachorro extends Animal{

    @Override
    public void consulta() {
        System.out.println("Consultando cachorro");
    }
}

class Gato extends Animal {

    @Override
    public void consulta() {
        System.out.println("Consultando gato");
    }
}

public class WildCardTest {
    public static void main(String[] args) {
        Cachorro[] cachorros = {new Cachorro(), new Cachorro()};
        Gato[] gatos = {new Gato(), new Gato()};

//        consultarAnimais(cachorros);
//        consultarAnimais(gatos);

        // O que se pode concluir?: Em arrays, é possível dar nos argumentos
        // do tipo Classe Pai, argumentos do tipo Classe Filha, pelo
        // polimorfismo

        List<Cachorro> cachorroList = new ArrayList<>();
        cachorroList.add(new Cachorro());
        List<Gato> gatoList = new ArrayList<>();
        gatoList.add(new Gato());

        consultarAnimaisList(cachorroList);
        consultarAnimaisList(gatoList);

        // Já em Lists, não é possível usar polimorfismo
        // (vai dar erro de compilação), os
        // argumentos devem ser dos mesmos tipos que os
        // parâmetros
        // Isso ocorre porque na hora de transformar as classes
        // em bytecode, os generics são ignorados
        // Como contornar?: usando o Wildcard (?)
    }

    public static void consultarAnimais(Animal[] animals) {
        for (Animal animal : animals) {
            animal.consulta();
        }
    }

    // Para que qualquer filha de animal possa servir de argumento:
    public static void consultarAnimaisList(List<? extends Animal> animals) {
        for (Animal animal : animals) {
            animal.consulta();
        }

    }

    // Para que qualquer super classe de cachorro ou ele mesmo possa servir de argumento:
    public static void consultarCachorroList(List<? super Cachorro> cachorroList){
        cachorroList.add(new Cachorro());
//        cachorroList.add(new Animal()); // Nesse caso, não se cria um objeto de animal pela classe Animal ser abstrata

    }

    // Também é possível criar condições para argumentos, por exemblo,
    // permitir a criação de uma lista apenas com itens contendo Comparable
    // "O argumento apresentado é um comparable?"
    public static void ordenarLista(List<? extends Comparable> lista){  //Regra: SEMPRE será extends escrito aq e n implements
        Collections.sort(lista);
    }
}
